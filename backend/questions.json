[
    {
        "question_id": 1,
        "design_pattern": "simple-refactoring",
        "context": "You are developing an inventory management system for a small bakery. The bakery sells various items like cakes, pastries, and bread.  Currently, each item type has its own class for managing its specific properties and operations (e.g., `Cake`, `Pastry`, `Bread`).  Each class has methods for getting the item name, calculating the price, and applying discounts.  However, this has led to a lot of code duplication, especially with the discount logic, which is essentially the same for all items.  Your task is to refactor the code to eliminate this redundancy using a more flexible and maintainable approach.",
        "code": "public class Cake {\n    private String name;\n    private double price;\n\n    public Cake(String name, double price) {\n        this.name = name;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n\n    public double getDiscountedPrice(double discount) {\n        return price * (1 - discount);\n    }\n}\n\npublic class Pastry {\n    private String name;\n    private double price;\n\n    public Pastry(String name, double price) {\n        this.name = name;\n        this.price = price;\n    }\n\n\n    public String getName() {\n        return name;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n\n    public double getDiscountedPrice(double discount) {\n        return price * (1 - discount);\n    }\n}\n\n\npublic class Bread {\n    private String name;\n    private double price;\n\n    public Bread(String name, double price) {\n        this.name = name;\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n\n    public double getDiscountedPrice(double discount) {\n        return price * (1 - discount);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Cake cake = new Cake(\"Chocolate Cake\", 10.0);\n        Pastry pastry = new Pastry(\"Croissant\", 2.5);\n        Bread bread = new Bread(\"Sourdough\", 5.0);\n\n        System.out.println(cake.getName() + \": $\" + cake.getDiscountedPrice(0.1));\n        System.out.println(pastry.getName() + \": $\" + pastry.getDiscountedPrice(0.1));\n        System.out.println(bread.getName() + \": $\" + bread.getDiscountedPrice(0.1));\n    }\n}"
    },
    {
        "question_id": 2,
        "design_pattern": "simple-refactoring",
        "context": "You're developing a system for a pizza restaurant. The restaurant offers various pizza types like Margherita, Pepperoni, and Veggie. Each pizza has a different preparation process, including specific dough preparation, topping placement, and baking time. Currently, the `Pizza` class handles all these variations using large, nested `if-else` blocks, making the code difficult to maintain and extend with new pizza types.  The code smells badly, and you need to refactor it for better readability and extensibility.",
        "code": "public class Pizza {\n\n    public enum PizzaType {\n        MARGHERITA, PEPPERONI, VEGGIE\n    }\n\n    private PizzaType type;\n\n    public Pizza(PizzaType type) {\n        this.type = type;\n    }\n\n    public void prepare() {\n        if (type == PizzaType.MARGHERITA) {\n            System.out.println(\"Preparing Margherita dough\");\n            System.out.println(\"Adding tomato sauce and mozzarella\");\n            System.out.println(\"Baking for 15 minutes\");\n        } else if (type == PizzaType.PEPPERONI) {\n            System.out.println(\"Preparing Pepperoni dough\");\n            System.out.println(\"Adding tomato sauce, mozzarella, and pepperoni\");\n            System.out.println(\"Baking for 20 minutes\");\n        } else if (type == PizzaType.VEGGIE) {\n            System.out.println(\"Preparing Veggie dough\");\n            System.out.println(\"Adding tomato sauce, mozzarella, and vegetables\");\n            System.out.println(\"Baking for 18 minutes\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Pizza margherita = new Pizza(PizzaType.MARGHERITA);\n        margherita.prepare();\n\n        Pizza pepperoni = new Pizza(PizzaType.PEPPERONI);\n        pepperoni.prepare();\n\n        Pizza veggie = new Pizza(PizzaType.VEGGIE);\n        veggie.prepare();\n    }\n}"
    },
    {
        "question_id": 3,
        "design_pattern": "simple-refactoring",
        "context": "You are developing a system for a pizza restaurant. The restaurant offers various pizza types (Pepperoni, Veggie, Margherita) and wants to be able to calculate the price for each pizza based on its ingredients and size. Currently, the `Pizza` class handles all the price calculations directly within each `Pizza` subclass.  This is becoming difficult to maintain as they introduce new pizza types and pricing changes become frequent.",
        "code": "public abstract class Pizza {\n\n    String name;\n    String size;\n\n    public Pizza(String name, String size) {\n        this.name = name;\n        this.size = size;\n    }\n\n    public abstract double calculatePrice();\n\n\n    public static class PepperoniPizza extends Pizza {\n\n        public PepperoniPizza(String size) {\n            super(\"Pepperoni\", size);\n        }\n\n        @Override\n        public double calculatePrice() {\n            double basePrice = 10.0;\n            if (size.equals(\"large\")) {\n                basePrice += 4.0;\n            } else if (size.equals(\"medium\")) {\n                basePrice += 2.0;\n            }\n            return basePrice;\n        }\n    }\n\n    public static class VeggiePizza extends Pizza {\n\n        public VeggiePizza(String size) {\n            super(\"Veggie\", size);\n        }\n\n\n        @Override\n        public double calculatePrice() {\n            double basePrice = 12.0;\n            if (size.equals(\"large\")) {\n                basePrice += 5.0;\n            } else if (size.equals(\"medium\")) {\n                basePrice += 3.0;\n            }\n            return basePrice;\n        }\n    }\n\n    public static class MargheritaPizza extends Pizza {\n\n        public MargheritaPizza(String size) {\n            super(\"Margherita\", size);\n        }\n\n        @Override\n        public double calculatePrice() {\n            double basePrice = 8.0;\n            if (size.equals(\"large\")) {\n                basePrice += 3.0;\n            } else if (size.equals(\"medium\")) {\n                basePrice += 1.0;\n            }\n            return basePrice;\n        }\n    }\n\n\n    public static void main(String[] args) {\n        Pizza pepperoni = new PepperoniPizza(\"large\");\n        System.out.println(pepperoni.calculatePrice());\n\n        Pizza veggie = new VeggiePizza(\"medium\");\n        System.out.println(veggie.calculatePrice());\n    }\n}"
    },
    {
        "question_id": 4,
        "design_pattern": "pattern-identification",
        "context": "You are developing a logging system for a large e-commerce platform.  Different parts of the system need to log messages with varying levels of severity (DEBUG, INFO, WARNING, ERROR).  Currently, logging is implemented directly within each component using `System.out.println()`. This approach makes it difficult to manage and filter logs, especially as the system grows.  You want to improve the logging system by introducing a more flexible and centralized mechanism.  Your goal is to identify a suitable design pattern to address this issue and refactor the existing code.",
        "code": "public class ProductCatalog {\n\n    public void addProduct(String productName, double price) {\n        System.out.println(\"Adding product: \" + productName + \" with price: \" + price);\n        // ... logic to add product to catalog ...\n    }\n\n    public void removeProduct(String productName) {\n        System.out.println(\"Removing product: \" + productName);\n        // ... logic to remove product from catalog ...\n    }\n}\n\n\npublic class OrderProcessing {\n\n    public void processOrder(int orderId) {\n        System.out.println(\"Processing order: \" + orderId);\n        // ... logic to process order ...\n        if (/* some error condition */ true) {\n            System.out.println(\"Error processing order: \" + orderId);\n        }\n    }\n}\n\n\npublic class PaymentGateway {\n\n    public void processPayment(double amount) {\n        System.out.println(\"Processing payment: \" + amount);\n        // ... logic to process payment ...\n        try {\n            // ... some operation that might throw an exception ...\n        } catch (Exception e) {\n            System.out.println(\"Payment failed: \" + e.getMessage());\n        }\n    }\n}\n\n\npublic class Main {\n    public static void main(String[] args) {\n        ProductCatalog catalog = new ProductCatalog();\n        catalog.addProduct(\"Laptop\", 1200.00);\n\n        OrderProcessing orderProcessing = new OrderProcessing();\n        orderProcessing.processOrder(12345);\n\n        PaymentGateway paymentGateway = new PaymentGateway();\n        paymentGateway.processPayment(50.00);\n    }\n}"
    },
    {
        "question_id": 5,
        "design_pattern": "pattern-identification",
        "context": "You are developing an inventory management system for a large online retailer.  The system needs to handle a wide variety of products, each with unique properties and behaviors. For example, books have ISBNs, electronics have serial numbers, and clothing has sizes and colors.  Currently, the system uses a large, monolithic `Product` class with many conditional statements to handle the different product types. This makes the code difficult to maintain and extend.  New product types require modifications to the existing `Product` class, increasing the risk of introducing bugs.",
        "code": "public class Product {\n\n    private String name;\n    private double price;\n    private String productType;\n\n    // Book-specific attributes\n    private String isbn;\n\n    // Electronics-specific attributes\n    private String serialNumber;\n\n    // Clothing-specific attributes\n    private String size;\n    private String color;\n\n\n    public Product(String name, double price, String productType) {\n        this.name = name;\n        this.price = price;\n        this.productType = productType;\n    }\n\n    public double calculateShippingCost() {\n        if (productType.equals(\"Book\")) {\n            // Book-specific shipping calculation\n            return 5.0;\n        } else if (productType.equals(\"Electronics\")) {\n            // Electronics-specific shipping calculation\n            return 10.0;\n        } else if (productType.equals(\"Clothing\")) {\n            // Clothing-specific shipping calculation\n            return 2.5;\n        } else {\n            return 7.5; // Default shipping cost\n        }\n    }\n\n\n    public void displayDetails() {\n        System.out.println(\"Name: \" + name);\n        System.out.println(\"Price: \" + price);\n\n        if (productType.equals(\"Book\")) {\n            System.out.println(\"ISBN: \" + isbn);\n        } else if (productType.equals(\"Electronics\")) {\n            System.out.println(\"Serial Number: \" + serialNumber);\n        } else if (productType.equals(\"Clothing\")) {\n            System.out.println(\"Size: \" + size);\n            System.out.println(\"Color: \" + color);\n        }\n    }\n\n    // Getters and setters for all attributes\n    // ...\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Product book = new Product(\"The Lord of the Rings\", 25.0, \"Book\");\n        book.isbn = \"978-0544003415\";\n        book.displayDetails();\n        System.out.println(\"Shipping Cost: \" + book.calculateShippingCost());\n\n\n        Product tv = new Product(\"Samsung TV\", 500.0, \"Electronics\");\n        tv.serialNumber= \"SAM12345\";\n        tv.displayDetails();\n        System.out.println(\"Shipping Cost: \" + tv.calculateShippingCost());\n    }\n}"
    },
    {
        "question_id": 6,
        "design_pattern": "pattern-identification",
        "context": "You are developing an e-commerce platform.  Customers can add items to their shopping cart. The system needs to calculate the total price, including discounts.  Currently, there are two types of discounts: percentage-based discounts (e.g., 10% off) and fixed-amount discounts (e.g., $5 off). More discount types may be added in the future. The current implementation uses a chain of `if/else` statements, which is becoming difficult to maintain as new discount types are introduced.",
        "code": "import java.util.List;\n\ninterface Discount {\n    double apply(double price);\n}\n\nclass PercentageDiscount implements Discount {\n    private double percentage;\n\n    public PercentageDiscount(double percentage) {\n        this.percentage = percentage;\n    }\n\n    @Override\n    public double apply(double price) {\n        return price * (1 - percentage);\n    }\n}\n\nclass FixedDiscount implements Discount {\n    private double amount;\n\n    public FixedDiscount(double amount) {\n        this.amount = amount;\n    }\n\n    @Override\n    public double apply(double price) {\n        return price - amount;\n    }\n}\n\n\nclass ShoppingCart {\n\n    private List<Discount> discounts;\n\n    public ShoppingCart(List<Discount> discounts) {\n        this.discounts = discounts;\n    }\n\n\n    public double calculateTotalPrice(List<Double> itemPrices) {\n        double totalPrice = 0;\n        for (Double price : itemPrices) {\n            totalPrice += price;\n        }\n\n        if (discounts != null) {\n            for (Discount discount : discounts) {\n                if (discount instanceof PercentageDiscount) {\n                    totalPrice = discount.apply(totalPrice);\n                } else if (discount instanceof FixedDiscount) {\n                    totalPrice = discount.apply(totalPrice);\n                } // What happens if we have a new discount type?\n            }\n        }\n\n\n\n        return totalPrice;\n    }\n}\n\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Double> prices = List.of(10.0, 20.0, 30.0);\n        List<Discount> discounts = List.of(new PercentageDiscount(0.1), new FixedDiscount(5.0));\n\n        ShoppingCart cart = new ShoppingCart(discounts);\n        double totalPrice = cart.calculateTotalPrice(prices);\n        System.out.println(\"Total price: \" + totalPrice);\n\n    }\n}"
    },
    {
        "question_id": 7,
        "design_pattern": "implement-singleton",
        "context": "You are developing a logging system for a large e-commerce platform.  Multiple services need to write to the same log file to track various events like orders, payments, and inventory updates.  Having multiple instances of the logger would lead to resource conflicts and inconsistent log entries.  Therefore, you need to ensure that only one instance of the logger exists throughout the application's lifecycle.",
        "code": "import java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Logger {\n\n    private static String logFile = \"application.log\";\n    private FileWriter writer;\n\n\n    public Logger() {\n        try {\n            this.writer = new FileWriter(logFile, true);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void log(String message) {\n        try {\n            writer.write(message + \"\\n\");\n            writer.flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        Logger logger1 = new Logger();\n        Logger logger2 = new Logger();\n\n        logger1.log(\"Order placed by user 123\");\n        logger2.log(\"Payment processed for order 456\");\n\n    }\n}"
    },
    {
        "question_id": 8,
        "design_pattern": "implement-singleton",
        "context": "You are building a logging system for a large e-commerce platform. Multiple parts of the application need to write log messages, but you want to ensure that all logs are written to a single file to avoid fragmentation and simplify analysis.  Currently, every time a new logging request is made, a new `Logger` instance is created, resulting in multiple log files being created. This makes log analysis a nightmare! You need to ensure that only one instance of the `Logger` exists and is used throughout the application.",
        "code": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class Logger {\n\n    private String logFile = \"application.log\";\n    private FileWriter writer;\n\n    public Logger() {\n        try {\n            writer = new FileWriter(logFile, true); // append mode\n        } catch (IOException e) {\n            System.err.println(\"Error creating log file: \" + e.getMessage());\n        }\n    }\n\n    public void log(String message) {\n        try {\n            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n            writer.write(timestamp + \": \" + message + \"\\n\");\n            writer.flush();\n        } catch (IOException e) {\n            System.err.println(\"Error writing to log file: \" + e.getMessage());\n        }\n    }\n\n\n    public static void main(String[] args) {\n        Logger logger1 = new Logger();\n        logger1.log(\"User logged in.\");\n\n        Logger logger2 = new Logger(); // Another instance!\n        logger2.log(\"Order placed.\");\n\n\n        // ... other parts of the application also create Logger instances ...\n    }\n}"
    },
    {
        "question_id": 9,
        "design_pattern": "implement-singleton",
        "context": "You are developing a logging system for a high-traffic e-commerce website.  Multiple threads need to write log entries concurrently. To avoid conflicts and ensure consistent formatting, you need a single point of access to the logging functionality.  Currently, multiple instances of the `Logger` class can be created, leading to issues with file access and formatting inconsistencies.",
        "code": "public class Logger {\n\n    private String logFile;\n\n    public Logger(String logFile) {\n        this.logFile = logFile;\n    }\n\n    public void log(String message) {\n        try (FileWriter writer = new FileWriter(logFile, true)) {\n            writer.write(message + \"\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        Logger logger1 = new Logger(\"application.log\");\n        Logger logger2 = new Logger(\"application.log\");\n\n        logger1.log(\"User logged in.\");\n        logger2.log(\"Order placed.\");\n    }\n}"
    },
    {
        "question_id": 10,
        "design_pattern": "builder-pattern",
        "context": "You are developing a pizza ordering system for a new online pizzeria. Customers should be able to customize their pizzas with various toppings, crust types, and sizes. Currently, the `Pizza` class constructor is becoming unwieldy with a growing number of optional parameters.  This makes the code difficult to read and prone to errors when ordering pizzas with many customizations.  Often, customers forget to specify parameters leading to default pizzas they didn't intend to order. For instance, a customer wanting a large pizza with only pepperoni might accidentally receive a small cheese pizza.",
        "code": "public class Pizza {\n\n    private String size;\n    private String crust;\n    private boolean cheese;\n    private boolean pepperoni;\n    private boolean mushrooms;\n    private boolean onions;\n    private boolean olives;\n\n    public Pizza(String size, String crust, boolean cheese, boolean pepperoni, boolean mushrooms, boolean onions, boolean olives) {\n        this.size = size;\n        this.crust = crust;\n        this.cheese = cheese;\n        this.pepperoni = pepperoni;\n        this.mushrooms = mushrooms;\n        this.onions = onions;\n        this.olives = olives;\n    }\n\n    //Other methods (e.g. calculatePrice, getIngredients) omitted for brevity\n\n    public static void main(String[] args) {\n        Pizza pizza1 = new Pizza(\"large\", \"thin\", true, true, false, false, false); // Pepperoni pizza\n        Pizza pizza2 = new Pizza(\"small\", \"thick\", true, false, false, false, false); // Simple cheese pizza\n        Pizza pizza3 = new Pizza(\"medium\", null, true, true, true, true, true); //Lots of toppings, forgot crust type!\n\n\n        // Many more pizza orders\u2026 leading to long and confusing constructor calls.\n    }\n}"
    },
    {
        "question_id": 11,
        "design_pattern": "builder-pattern",
        "context": "You are developing a pizza ordering system for a new online restaurant. Customers should be able to customize their pizzas with various toppings, crust types, and sizes.  Currently, the `Pizza` class constructor is becoming unwieldy with too many parameters, making it difficult to maintain and prone to errors.  Orders are frequently incorrect due to mismatched parameters in the constructor calls.  Simplify the ordering process and improve code maintainability by implementing the Builder pattern.",
        "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Pizza {\n\n    private String size;\n    private String crust;\n    private List<String> toppings;\n\n    public Pizza(String size, String crust, List<String> toppings) {\n        this.size = size;\n        this.crust = crust;\n        this.toppings = toppings;\n    }\n\n\n    public static void main(String[] args) {\n        List<String> toppings1 = new ArrayList<>();\n        toppings1.add(\"pepperoni\");\n        toppings1.add(\"mushrooms\");\n\n        Pizza pizza1 = new Pizza(\"large\", \"thin\", toppings1);\n\n        List<String> toppings2 = new ArrayList<>(); // Lots of boilerplate for creating lists\n        toppings2.add(\"olives\");\n        toppings2.add(\"onions\");\n        toppings2.add(\"extra cheese\");\n\n\n        Pizza pizza2 = new Pizza(\"medium\", \"thick\", toppings2); // Many parameters - error prone!\n\n\t\t// Imagine several more pizzas being constructed in a similar tedious way.\n\t\t// It's also easy to accidentally switch the order of parameters.\n    }\n\n    // Getters for size, crust, and toppings... (omitted for brevity)\n\n}"
    },
    {
        "question_id": 12,
        "design_pattern": "builder-pattern",
        "context": "You are developing a pizza ordering system for a new online delivery service.  Customers should be able to customize their pizzas with various toppings, crust types, and sizes.  Currently, the `Pizza` class constructor is becoming unwieldy with too many parameters, making it difficult to manage and prone to errors.  Furthermore, some parameters are optional, leading to confusing constructor calls with null values.  Simplify the pizza creation process and improve code readability.",
        "code": "public class Pizza {\n\n    private String size;\n    private String crust;\n    private boolean cheese;\n    private boolean pepperoni;\n    private boolean mushrooms;\n    private boolean onions;\n\n    public Pizza(String size, String crust, boolean cheese, boolean pepperoni, boolean mushrooms, boolean onions) {\n        this.size = size;\n        this.crust = crust;\n        this.cheese = cheese;\n        this.pepperoni = pepperoni;\n        this.mushrooms = mushrooms;\n        this.onions = onions;\n    }\n\n\n    public static void main(String[] args) {\n        Pizza pizza1 = new Pizza(\"large\", \"thin\", true, true, false, null); // Confusing null usage\n        Pizza pizza2 = new Pizza(\"medium\", \"thick\", true, false, false, false);\n        Pizza pizza3 = new Pizza(\"small\", \"thin\", true, false, true, true); // Lots of parameters!\n\n\n        // ... more pizza creation logic\n    }\n\n\n\n    // Getters for all fields (omitted for brevity)\n\n}"
    },
    {
        "question_id": 13,
        "design_pattern": "adapter-pattern",
        "context": "You are developing a new inventory management system for a large electronics retailer.  Your system needs to interact with a legacy inventory database that uses an outdated `LegacyInventorySystem` class. This legacy system has a method `getStockLevel(String productName)` that returns an integer representing the number of items in stock.\n\nYour new inventory system uses a modern `InventoryManagement` class that expects an `InventoryProvider` interface with a method `getItemCount(String productID)` to retrieve stock information.  Unfortunately, the `LegacyInventorySystem` doesn't implement this interface, and directly modifying the legacy code is not allowed. You need a way to bridge the gap between your new system and the old one.",
        "code": "interface InventoryProvider {\n    int getItemCount(String productID);\n}\n\nclass InventoryManagement {\n    private InventoryProvider inventoryProvider;\n\n    public InventoryManagement(InventoryProvider inventoryProvider) {\n        this.inventoryProvider = inventoryProvider;\n    }\n\n    public void displayStock(String productID) {\n        int count = inventoryProvider.getItemCount(productID);\n        System.out.println(\"Stock for \" + productID + \": \" + count);\n    }\n}\n\n\nclass LegacyInventorySystem {\n    public int getStockLevel(String productName) {\n        // Imagine complex legacy logic here connecting to an old database\n        // For demonstration, we'll just return a dummy value\n        if (productName.equals(\"Laptop\")) return 10;\n        if (productName.equals(\"Mouse\")) return 50;\n        return 0; \n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        LegacyInventorySystem legacySystem = new LegacyInventorySystem();\n        InventoryManagement inventoryManagement = new InventoryManagement( /* What goes here? */ ); \n\n        inventoryManagement.displayStock(\"Laptop\");\n    }\n}"
    },
    {
        "question_id": 14,
        "design_pattern": "adapter-pattern",
        "context": "You are developing a new inventory management system for a large electronics retailer.  Your system needs to integrate with an older legacy system that tracks product information.  Unfortunately, the legacy system uses an outdated `LegacyProduct` interface, while your new system is designed to work with the modern `Product` interface. You need a way to seamlessly integrate the legacy product data into your new system without modifying the core code of either system.",
        "code": "interface Product {\n    String getName();\n    double getPrice();\n    String getSku();\n}\n\ninterface LegacyProduct {\n    String getTitle();\n    double getCost();\n    String getProductId();\n}\n\nclass LegacyProductImpl implements LegacyProduct {\n    private String title;\n    private double cost;\n    private String productId;\n\n    public LegacyProductImpl(String title, double cost, String productId) {\n        this.title = title;\n        this.cost = cost;\n        this.productId = productId;\n    }\n\n    @Override\n    public String getTitle() {\n        return title;\n    }\n\n    @Override\n    public double getCost() {\n        return cost;\n    }\n\n    @Override\n    public String getProductId() {\n        return productId;\n    }\n}\n\n\nclass InventorySystem {\n\n    public void addProduct(Product product) {\n        System.out.println(\"Adding product: \" + product.getName() + \", SKU: \" + product.getSku() + \", Price: \" + product.getPrice());\n\n        // ... other inventory management logic ...\n    }\n\n\n    public static void main(String[] args) {\n        InventorySystem inventory = new InventorySystem();\n        LegacyProduct legacyProduct = new LegacyProductImpl(\"Legacy TV\", 500.00, \"LEG-TV-001\");\n\n        //  This line causes a compilation error. How can you use the legacyProduct with the InventorySystem?\n        inventory.addProduct(legacyProduct); \n    }\n}"
    },
    {
        "question_id": 15,
        "design_pattern": "adapter-pattern",
        "context": "You are building a new analytics dashboard for an e-commerce platform.  You want to integrate with two different analytics services: `NewAnalytics` and `LegacyAnalytics`.  Unfortunately, they have different interfaces for logging events.  `NewAnalytics` uses a modern `AnalyticEvent` interface, while `LegacyAnalytics` uses an older, incompatible `LegacyEvent` interface. You need to be able to send events to both services without modifying their existing code.",
        "code": "interface AnalyticEvent {\n    String getName();\n    String getValue();\n}\n\nclass PurchaseEvent implements AnalyticEvent {\n    private String productName;\n    private double price;\n\n    public PurchaseEvent(String productName, double price) {\n        this.productName = productName;\n        this.price = price;\n    }\n\n    @Override\n    public String getName() {\n        return \"purchase\";\n    }\n\n    @Override\n    public String getValue() {\n        return productName + \":\" + price;\n    }\n}\n\n\ninterface LegacyEvent {\n    String getEventType();\n    String getEventData();\n}\n\nclass LegacyPurchaseEvent implements LegacyEvent {\n    private String productName;\n    private double price;\n\n\n    public LegacyPurchaseEvent(String productName, double price) {\n        this.productName = productName;\n        this.price = price;\n    }\n\n    @Override\n    public String getEventType() {\n        return \"PURCHASE\";\n    }\n\n    @Override\n    public String getEventData() {\n        return productName + \" - $\" + price;\n    }\n}\n\n\n\nclass AnalyticsDashboard {\n    private NewAnalytics newAnalytics;\n    private LegacyAnalytics legacyAnalytics;\n\n    public AnalyticsDashboard(NewAnalytics newAnalytics, LegacyAnalytics legacyAnalytics) {\n        this.newAnalytics = newAnalytics;\n        this.legacyAnalytics = legacyAnalytics;\n    }\n\n    public void recordPurchase(String productName, double price) {\n        PurchaseEvent newEvent = new PurchaseEvent(productName, price);\n        newAnalytics.logEvent(newEvent);\n\n        LegacyPurchaseEvent legacyEvent = new LegacyPurchaseEvent(productName, price);\n        legacyAnalytics.logEvent(legacyEvent);\n        // The LegacyAnalytics service needs some sort of adaptation to work with the new system\n    }\n}\n\n\n\nclass NewAnalytics {\n    public void logEvent(AnalyticEvent event) {\n        System.out.println(\"NewAnalytics: \" + event.getName() + \" - \" + event.getValue());\n    }\n\n}\n\nclass LegacyAnalytics {\n    public void logEvent(LegacyEvent event) {\n        System.out.println(\"LegacyAnalytics: \" + event.getEventType() + \" - \" + event.getEventData());\n    }\n\n\n}\n\n\n\npublic class Main {\n    public static void main(String[] args) {\n        NewAnalytics newAnalytics = new NewAnalytics();\n        LegacyAnalytics legacyAnalytics = new LegacyAnalytics();\n        AnalyticsDashboard dashboard = new AnalyticsDashboard(newAnalytics, legacyAnalytics);\n        dashboard.recordPurchase(\"Shoes\", 99.99);\n\n    }\n}"
    },
    {
        "question_id": 16,
        "design_pattern": "facade-pattern",
        "context": "You are developing a smart home automation system. Users can control various subsystems like lighting, heating, and security through a central interface. Currently, interacting with each subsystem requires complex and specific method calls. This makes the user interface cumbersome and difficult to maintain.  Simplify the interaction with the smart home subsystems by implementing a facade.",
        "code": "public class LightingSystem {\n    public void turnOnLights(String room) {\n        System.out.println(\"Turning on lights in \" + room);\n        // Complex lighting logic here...\n    }\n\n    public void turnOffLights(String room) {\n        System.out.println(\"Turning off lights in \" + room);\n        // More complex lighting logic...\n    }\n\n    public void setBrightness(String room, int level) {\n        System.out.println(\"Setting brightness in \" + room + \" to \" + level);\n        // Even more complex lighting logic...\n    }\n}\n\npublic class HeatingSystem {\n    public void setTemperature(double temperature) {\n        System.out.println(\"Setting temperature to \" + temperature + \"\u00b0C\");\n        // Complex temperature control logic...\n    }\n\n    public void turnOnHeating() {\n        System.out.println(\"Turning on heating\");\n        // More complex heating logic...\n    }\n\n    public void turnOffHeating() {\n        System.out.println(\"Turning off heating\");\n        // Yet more complex heating logic...\n    }\n}\n\npublic class SecuritySystem {\n    public void activateAlarm() {\n        System.out.println(\"Activating alarm\");\n        // Complex security logic...\n    }\n\n    public void deactivateAlarm() {\n        System.out.println(\"Deactivating alarm\");\n        // More complex security logic...\n    }\n\n    public void checkSensors() {\n        System.out.println(\"Checking sensors\");\n        // And even more complex security logic...\n    }\n}\n\npublic class SmartHomeUserInterface {\n    private LightingSystem lightingSystem = new LightingSystem();\n    private HeatingSystem heatingSystem = new HeatingSystem();\n    private SecuritySystem securitySystem = new SecuritySystem();\n\n    public void turnOnLivingRoomLights() {\n        lightingSystem.turnOnLights(\"Living Room\");\n    }\n\n    public void setHouseTemperature(double temperature) {\n        heatingSystem.setTemperature(temperature);\n    }\n\n    public void activateSecuritySystem() {\n        securitySystem.activateAlarm();\n    }\n\n    // Many more individual methods for each subsystem action...\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        SmartHomeUserInterface ui = new SmartHomeUserInterface();\n        ui.turnOnLivingRoomLights();\n        ui.setHouseTemperature(20);\n        ui.activateSecuritySystem();\n\n        // Imagine many more calls to individual subsystem methods here...\n    }\n}"
    },
    {
        "question_id": 17,
        "design_pattern": "facade-pattern",
        "context": "You are developing a smart home automation system.  Users can control various subsystems like lighting, heating, and security through a mobile app.  Currently, the app code is directly interacting with each subsystem's complex API, making the code cluttered and difficult to maintain.  For example, activating the \"movie mode\" requires several calls to different subsystems: dimming the lights, closing the blinds, turning on the projector, and starting the surround sound system.  Simplify the interaction with these subsystems using the Facade pattern.",
        "code": "public class LightingSystem {\n    public void dimLights(int percentage) {\n        System.out.println(\"Dimming lights to \" + percentage + \"%\");\n        // Complex lighting logic here...\n    }\n\n    public void turnOffLights() {\n        System.out.println(\"Turning off lights\");\n        // Complex lighting logic here...\n    }\n}\n\npublic class BlindSystem {\n    public void closeBlinds() {\n        System.out.println(\"Closing blinds\");\n        // Complex blind control logic here...\n    }\n\n    public void openBlinds() {\n        System.out.println(\"Opening blinds\");\n        // Complex blind control logic here...\n    }\n}\n\npublic class Projector {\n    public void turnOn() {\n        System.out.println(\"Turning on projector\");\n        // Complex projector control logic here...\n    }\n\n    public void turnOff() {\n        System.out.println(\"Turning off projector\");\n        // Complex projector control logic here...\n    }\n}\n\n\npublic class SurroundSoundSystem {\n    public void startSystem() {\n        System.out.println(\"Starting surround sound system\");\n        // Complex audio logic here...\n    }\n\n    public void stopSystem() {\n        System.out.println(\"Stopping surround sound system\");\n        // Complex audio logic here...\n    }\n}\n\npublic class SmartHomeApp {\n    private LightingSystem lightingSystem;\n    private BlindSystem blindSystem;\n    private Projector projector;\n    private SurroundSoundSystem surroundSoundSystem;\n\n    public SmartHomeApp() {\n        lightingSystem = new LightingSystem();\n        blindSystem = new BlindSystem();\n        projector = new Projector();\n        surroundSoundSystem = new SurroundSoundSystem();\n    }\n\n    public void activateMovieMode() {\n        lightingSystem.dimLights(20);\n        blindSystem.closeBlinds();\n        projector.turnOn();\n        surroundSoundSystem.startSystem();\n    }\n\n\n    public static void main(String[] args) {\n        SmartHomeApp app = new SmartHomeApp();\n        app.activateMovieMode();\n    }\n}"
    },
    {
        "question_id": 18,
        "design_pattern": "facade-pattern",
        "context": "You are building a smart home system.  Users can control various subsystems like lights, thermostat, and security cameras through a central interface. Currently, interacting with each subsystem requires dealing with their complex individual APIs. This makes the overall system difficult to use and maintain. Simplify the user interaction by implementing a facade that provides a unified interface for managing all smart home components.",
        "code": "// Subsystem classes\n\nclass LightingSystem {\n    public void turnOnLights(String room) {\n        System.out.println(\"Turning on lights in \" + room);\n        // Complex lighting logic...\n    }\n\n    public void turnOffLights(String room) {\n        System.out.println(\"Turning off lights in \" + room);\n        // Complex lighting logic...\n    }\n}\n\nclass Thermostat {\n    public void setTemperature(int temperature) {\n        System.out.println(\"Setting temperature to \" + temperature + \" degrees\");\n        // Complex thermostat logic...\n    }\n\n    public int getTemperature() {\n        System.out.println(\"Getting current temperature...\");\n        // Complex thermostat logic...\n        return 22; // Placeholder\n    }\n}\n\nclass SecurityCamera {\n    public void activateCamera(int cameraId) {\n        System.out.println(\"Activating camera \" + cameraId);\n        // Complex camera activation logic...\n    }\n\n    public void deactivateCamera(int cameraId) {\n        System.out.println(\"Deactivating camera \" + cameraId);\n        // Complex camera deactivation logic...\n    }\n}\n\n\n// Client code (needs to be simplified with Facade)\n\npublic class SmartHomeClient {\n    public static void main(String[] args) {\n        LightingSystem lights = new LightingSystem();\n        Thermostat thermostat = new Thermostat();\n        SecurityCamera camera = new SecurityCamera();\n\n        lights.turnOnLights(\"Living Room\");\n        thermostat.setTemperature(24);\n        camera.activateCamera(1);\n\n        // ... more complex interactions with each subsystem ...\n\n        lights.turnOffLights(\"Living Room\");\n        camera.deactivateCamera(1);\n    }\n}"
    },
    {
        "question_id": 19,
        "design_pattern": "factory-method",
        "context": "You are developing a cross-platform mobile game.  The game needs to display ads to generate revenue.  However, the ad SDKs are different for Android and iOS.  Currently, the `AdManager` class directly instantiates either an `AndroidAd` or `iOSAd` based on a platform string.  This makes the code inflexible and difficult to extend to new platforms in the future. Refactor the code to use the Factory Method pattern.",
        "code": "public class AdManager {\n\n    private String platform;\n\n    public AdManager(String platform) {\n        this.platform = platform;\n    }\n\n    public void displayAd() {\n        Ad ad;\n        if (platform.equals(\"android\")) {\n            ad = new AndroidAd();\n        } else if (platform.equals(\"ios\")) {\n            ad = new iOSAd();\n        } else {\n            throw new RuntimeException(\"Unsupported platform: \" + platform);\n        }\n        ad.loadAd();\n        ad.showAd();\n    }\n}\n\n\npublic class AndroidAd extends Ad {\n\n    @Override\n    public void loadAd() {\n        System.out.println(\"Loading Android ad...\");\n    }\n\n    @Override\n    public void showAd() {\n        System.out.println(\"Showing Android ad...\");\n    }\n}\n\npublic class iOSAd extends Ad {\n\n    @Override\n    public void loadAd() {\n        System.out.println(\"Loading iOS ad...\");\n    }\n\n    @Override\n    public void showAd() {\n        System.out.println(\"Showing iOS ad...\");\n    }\n}\n\npublic abstract class Ad {\n    public abstract void loadAd();\n    public abstract void showAd();\n}\n\n\npublic class Main {\n    public static void main(String[] args) {\n        AdManager manager = new AdManager(\"android\");\n        manager.displayAd();\n\n        manager = new AdManager(\"ios\");\n        manager.displayAd();\n    }\n}"
    },
    {
        "question_id": 20,
        "design_pattern": "factory-method",
        "context": "You are developing a cross-platform mobile game.  The game needs to display advertisements to generate revenue. However, the ad platforms differ slightly between Android and iOS. You have `AndroidAd` and `iOSAd` classes to handle platform-specific ad logic (like displaying banners and interstitials).  Currently, the game's `AdManager` creates ads directly using constructors, leading to platform-dependent code scattered throughout the game logic. This makes it difficult to add support for new ad platforms in the future. Refactor the code to utilize the factory-method pattern to decouple ad creation from the game logic.",
        "code": "public class AdManager {\n\n    private String platform;\n\n    public AdManager(String platform) {\n        this.platform = platform;\n    }\n\n    public void displayAd() {\n        if (platform.equals(\"android\")) {\n            AndroidAd ad = new AndroidAd();\n            ad.displayBanner();\n            ad.displayInterstitial();\n        } else if (platform.equals(\"ios\")) {\n            iOSAd ad = new iOSAd();\n            ad.displayBanner();\n            ad.displayInterstitial();\n        } else {\n            System.out.println(\"Unsupported platform\");\n        }\n    }\n\n\n    public static void main(String[] args) {\n        AdManager androidManager = new AdManager(\"android\");\n        androidManager.displayAd();\n\n        AdManager iosManager = new AdManager(\"ios\");\n        iosManager.displayAd();\n    }\n}\n\n\nclass AndroidAd {\n    public void displayBanner() {\n        System.out.println(\"Displaying Android banner ad\");\n    }\n\n    public void displayInterstitial() {\n        System.out.println(\"Displaying Android interstitial ad\");\n    }\n}\n\nclass iOSAd {\n    public void displayBanner() {\n        System.out.println(\"Displaying iOS banner ad\");\n    }\n\n    public void displayInterstitial() {\n        System.out.println(\"Displaying iOS interstitial ad\");\n    }\n}"
    },
    {
        "question_id": 21,
        "design_pattern": "factory-method",
        "context": "You are developing an online pizza ordering system.  Customers can choose from various pizza types like Pepperoni, Vegetarian, and Hawaiian. Each pizza has a different preparation process, including specific ingredients and baking instructions. Currently, the `PizzaShop` class is responsible for creating all types of pizzas directly, leading to a large, complex, and difficult-to-maintain `createPizza` method. This makes adding new pizza types cumbersome and prone to errors.  Refactor the system using the factory-method pattern to improve code organization and extensibility.",
        "code": "public class PizzaShop {\n\n    public enum PizzaType {\n        PEPPERONI, VEGETARIAN, HAWAIIAN\n    }\n\n    public Pizza createPizza(PizzaType type) {\n        Pizza pizza = null;\n\n        if (type == PizzaType.PEPPERONI) {\n            pizza = new Pizza(\"Pepperoni\");\n            pizza.addIngredient(\"Pepperoni\");\n            pizza.addIngredient(\"Cheese\");\n            pizza.addIngredient(\"Tomato Sauce\");\n            pizza.bake(\"400F\", \"20 minutes\");\n        } else if (type == PizzaType.VEGETARIAN) {\n            pizza = new Pizza(\"Vegetarian\");\n            pizza.addIngredient(\"Onions\");\n            pizza.addIngredient(\"Peppers\");\n            pizza.addIngredient(\"Mushrooms\");\n            pizza.addIngredient(\"Cheese\");\n            pizza.addIngredient(\"Tomato Sauce\");\n            pizza.bake(\"375F\", \"25 minutes\");\n        } else if (type == PizzaType.HAWAIIAN) {\n            pizza = new Pizza(\"Hawaiian\");\n            pizza.addIngredient(\"Ham\");\n            pizza.addIngredient(\"Pineapple\");\n            pizza.addIngredient(\"Cheese\");\n            pizza.addIngredient(\"Tomato Sauce\");\n            pizza.bake(\"425F\", \"18 minutes\");\n        }\n\n        return pizza;\n    }\n\n\n    public static void main(String[] args) {\n        PizzaShop shop = new PizzaShop();\n        Pizza pepperoniPizza = shop.createPizza(PizzaType.PEPPERONI);\n        System.out.println(\"Ordered a \" + pepperoniPizza.getName());\n\n        Pizza vegetarianPizza = shop.createPizza(PizzaType.VEGETARIAN);\n        System.out.println(\"Ordered a \" + vegetarianPizza.getName());\n    }\n}\n\n\n\nclass Pizza {\n    private String name;\n\n    public Pizza(String name) {\n        this.name = name;\n    }\n\n    public void addIngredient(String ingredient) {\n        System.out.println(\"Adding \" + ingredient + \" to \" + name);\n    }\n\n    public void bake(String temperature, String duration) {\n        System.out.println(\"Baking \" + name + \" at \" + temperature + \" for \" + duration);\n    }\n\n    public String getName() {\n        return name;\n    }\n}"
    },
    {
        "question_id": 22,
        "design_pattern": "observer-pattern",
        "context": "A weather station needs to update several displays (current temperature, wind speed, humidity) simultaneously whenever a new weather reading is available. Currently, the weather station class is directly calling update methods on each display, making the system tightly coupled and difficult to extend with new display types.  Users often complain about delayed updates and occasional crashes when a display malfunctions.",
        "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class WeatherStation {\n\n    private double temperature;\n    private double windSpeed;\n    private double humidity;\n\n    private List<Display> displays = new ArrayList<>();\n\n\n    public void addDisplay(Display display) {\n        displays.add(display);\n    }\n\n    public void setMeasurements(double temperature, double windSpeed, double humidity) {\n        this.temperature = temperature;\n        this.windSpeed = windSpeed;\n        this.humidity = humidity;\n\n        for (Display display : displays) {\n            display.update(temperature, windSpeed, humidity); // Directly updating each display\n        }\n\n    }\n\n    public static void main(String[] args) {\n        WeatherStation weatherStation = new WeatherStation();\n\n        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay();\n        StatisticsDisplay statisticsDisplay = new StatisticsDisplay();\n\n        weatherStation.addDisplay(currentConditionsDisplay);\n        weatherStation.addDisplay(statisticsDisplay);\n\n\n        weatherStation.setMeasurements(25, 10, 60);\n        weatherStation.setMeasurements(28, 15, 70);\n\n\n    }\n}\n\n\n\ninterface Display {\n    public void update(double temperature, double windSpeed, double humidity);\n\n}\n\nclass CurrentConditionsDisplay implements Display{\n\n\n    @Override\n    public void update(double temperature, double windSpeed, double humidity) {\n        System.out.println(\"Current conditions: \" + temperature + \"C degrees, \" + humidity + \"% humidity, \" + windSpeed +\" km/h wind speed\");\n    }\n}\n\n\nclass StatisticsDisplay implements Display{\n\n\n    @Override\n    public void update(double temperature, double windSpeed, double humidity) {\n        System.out.println(\"Calculating stats... (Not implemented yet, just printing dummy values)\");\n        System.out.println(\"Avg Temp: 20, Max Wind: 30,  Avg Humidity: 50\");\n    }\n}"
    },
    {
        "question_id": 23,
        "design_pattern": "observer-pattern",
        "context": "A weather station needs to display the current temperature and humidity on multiple displays throughout a building.  These displays can be of different types (e.g., LCD, LED, projections) and new display types might be added in the future.  The WeatherStation class currently updates each display individually, which is becoming difficult to maintain as the number of displays grows.",
        "code": "import java.util.ArrayList;\nimport java.util.List;\n\ninterface Display {\n    void update(float temperature, float humidity);\n}\n\nclass LCDDisplay implements Display {\n    @Override\n    public void update(float temperature, float humidity) {\n        System.out.println(\"LCD: Temperature: \" + temperature + \", Humidity: \" + humidity);\n    }\n}\n\nclass LEDDisplay implements Display {\n    @Override\n    public void update(float temperature, float humidity) {\n        System.out.println(\"LED: Temperature: \" + temperature + \", Humidity: \" + humidity);\n    }\n}\n\npublic class WeatherStation {\n    private float temperature;\n    private float humidity;\n    private List<Display> displays = new ArrayList<>();\n\n    public void addDisplay(Display display) {\n        displays.add(display);\n    }\n\n    public void setMeasurements(float temperature, float humidity) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n\n        for (Display display : displays) {\n            display.update(temperature, humidity);\n        }\n    }\n\n\n    public static void main(String[] args) {\n        WeatherStation weatherStation = new WeatherStation();\n\n        LCDDisplay lcdDisplay = new LCDDisplay();\n        LEDDisplay ledDisplay = new LEDDisplay();\n\n        weatherStation.addDisplay(lcdDisplay);\n        weatherStation.addDisplay(ledDisplay);\n\n        weatherStation.setMeasurements(25.5f, 60.2f);\n        weatherStation.setMeasurements(27.0f, 65.8f);\n\n\n\n    }\n}"
    },
    {
        "question_id": 24,
        "design_pattern": "observer-pattern",
        "context": "A weather station needs to update several displays simultaneously whenever a new measurement is taken.  These displays show different aspects of the weather data, such as temperature, humidity, and wind speed.  Currently, the weather station class is directly responsible for updating each display individually, leading to tight coupling and making it difficult to add new display types.",
        "code": "public interface WeatherDisplay {\n    void update(float temperature, float humidity, float pressure);\n}\n\npublic class CurrentConditionsDisplay implements WeatherDisplay {\n\n    private float temperature;\n    private float humidity;\n\n    public CurrentConditionsDisplay(WeatherStation weatherStation) {\n        // TODO: Register with weather station somehow\n    }\n\n    public void update(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        display();\n    }\n\n\n    public void display() {\n        System.out.println(\"Current conditions: \" + temperature + \"F degrees and \" + humidity + \"% humidity\");\n    }\n}\n\n\npublic class StatisticsDisplay implements WeatherDisplay{\n    private float maxTemp = 0.0f;\n    private float minTemp = 200;\n    private float tempSum= 0.0f;\n    private int numReadings;\n\n    public StatisticsDisplay(WeatherStation weatherStation) {\n        // TODO: Register with weather station somehow\n    }\n\n    public void update(float temperature, float humidity, float pressure) {\n        tempSum += temperature;\n        numReadings++;\n\n        if (temperature > maxTemp) {\n            maxTemp = temperature;\n        }\n\n        if (temperature < minTemp) {\n            minTemp = temperature;\n        }\n\n        display();\n    }\n\n    public void display() {\n        System.out.println(\"Avg/Max/Min temperature = \" + (tempSum / numReadings)\n            + \"/\" + maxTemp + \"/\" + minTemp);\n    }\n}\n\n\n\npublic class WeatherStation {\n    private float temperature;\n    private float humidity;\n    private float pressure;\n\n    public WeatherStation() {}\n\n    public void setMeasurements(float temperature, float humidity, float pressure) {\n        this.temperature = temperature;\n        this.humidity = humidity;\n        this.pressure = pressure;\n        //TODO: Notify displays\n        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(this);\n        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(this);\n\n        currentConditionsDisplay.update(temperature, humidity, pressure);\n        statisticsDisplay.update(temperature, humidity, pressure);\n\n\n    }\n\n    // TODO: Methods for registering/removing observers\n\n\n}\n\n\npublic class Main {\n    public static void main(String[] args) {\n        WeatherStation weatherStation = new WeatherStation();\n\n        weatherStation.setMeasurements(80, 65, 30.4f);\n        weatherStation.setMeasurements(82, 70, 29.2f);\n        weatherStation.setMeasurements(78, 90, 29.2f);\n    }\n}"
    },
    {
        "question_id": 25,
        "design_pattern": "strategy-pattern",
        "context": "You are developing a navigation app for hikers. The app needs to calculate the estimated time to reach a destination based on different terrains. Currently, the app supports hiking on flat ground and uphill, but more terrain types (e.g., downhill, rocky) will be added in the future. The current implementation uses a long chain of `if/else` statements, making it difficult to add new terrain types and potentially introducing bugs.  Refactor the code using the Strategy Pattern to make it more flexible and maintainable.",
        "code": "public class HikingTimeCalculator {\n\n    public enum Terrain {\n        FLAT, UPHILL\n    }\n\n    public double calculateEstimatedTime(double distance, Terrain terrain, double speed) {\n        double time = 0;\n\n        if (terrain == Terrain.FLAT) {\n            time = distance / speed;\n        } else if (terrain == Terrain.UPHILL) {\n            time = distance / (speed * 0.75); // Reduced speed due to incline\n        } \n        // More terrain types will be added here in the future like downhill, rocky, etc..\n\n        return time;\n    }\n\n    public static void main(String[] args) {\n        HikingTimeCalculator calculator = new HikingTimeCalculator();\n        double flatTime = calculator.calculateEstimatedTime(10, Terrain.FLAT, 5);\n        System.out.println(\"Estimated time for flat terrain: \" + flatTime);\n\n        double uphillTime = calculator.calculateEstimatedTime(5, Terrain.UPHILL, 2);\n        System.out.println(\"Estimated time for uphill terrain: \" + uphillTime);\n\n\n    }\n}"
    },
    {
        "question_id": 26,
        "design_pattern": "strategy-pattern",
        "context": "You are developing a shipping cost calculator for an e-commerce platform.  The platform supports multiple shipping methods: FedEx, UPS, and Postal Service. Each shipping method has its own unique way of calculating cost based on weight, dimensions, and destination.  Currently, the shipping cost calculation is implemented using a complex chain of if-else statements, making it difficult to add new shipping methods or modify existing ones.  Refactor the code to use the Strategy Pattern to improve maintainability and extensibility.",
        "code": "public class ShippingCostCalculator {\n\n    public double calculateShippingCost(String shippingMethod, double weight, double dimensions, String destination) {\n        if (shippingMethod.equals(\"FedEx\")) {\n            // Complex FedEx-specific calculation based on weight, dimensions, and destination\n            return weight * 2 + dimensions * 0.5 + (destination.equals(\"International\") ? 50 : 10);\n        } else if (shippingMethod.equals(\"UPS\")) {\n            // Complex UPS-specific calculation based on weight, dimensions, and destination\n            return weight * 1.5 + dimensions * 0.75 + (destination.equals(\"International\") ? 75 : 15);\n        } else if (shippingMethod.equals(\"Postal Service\")) {\n            // Complex Postal Service-specific calculation based on weight, dimensions, and destination\n            return weight + dimensions * 0.25 + (destination.equals(\"International\") ? 25 : 5);\n        } else {\n            throw new IllegalArgumentException(\"Invalid shipping method.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        ShippingCostCalculator calculator = new ShippingCostCalculator();\n        double cost = calculator.calculateShippingCost(\"FedEx\", 10, 20, \"Domestic\");\n        System.out.println(\"Shipping cost: \" + cost); \n        cost = calculator.calculateShippingCost(\"UPS\", 5, 10, \"International\");\n        System.out.println(\"Shipping cost: \" + cost);\n\n    }\n}"
    },
    {
        "question_id": 27,
        "design_pattern": "strategy-pattern",
        "context": "You are developing a shipping cost calculator for an e-commerce platform. The platform supports various shipping methods, including FedEx, UPS, and USPS. Each shipping method has its own way of calculating the shipping cost based on factors like weight, dimensions, and destination.  Currently, the shipping cost calculation is implemented using a large, complex `if-else` block, making it difficult to add new shipping methods or modify existing ones.",
        "code": "public class ShippingCostCalculator {\n\n    public double calculateShippingCost(String shippingMethod, double weight, double dimensions, String destination) {\n        if (shippingMethod.equals(\"FedEx\")) {\n            // Complex FedEx-specific calculation logic\n            return weight * 2 + dimensions * 0.5; \n        } else if (shippingMethod.equals(\"UPS\")) {\n            // Complex UPS-specific calculation logic\n            return weight * 1.5 + dimensions * 0.75;\n        } else if (shippingMethod.equals(\"USPS\")) {\n            // Complex USPS-specific calculation logic\n            return weight * 1 + dimensions * 1;\n        } else {\n            throw new IllegalArgumentException(\"Invalid shipping method.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        ShippingCostCalculator calculator = new ShippingCostCalculator();\n        double cost = calculator.calculateShippingCost(\"FedEx\", 5, 10, \"New York\");\n        System.out.println(\"Shipping cost: \" + cost);\n    }\n}"
    },
    {
        "question_id": 28,
        "design_pattern": "complex-decorator",
        "context": "You are developing an online food ordering system for a pizza restaurant.  Customers can customize their pizzas with various toppings. Each topping has a cost associated with it.  The base pizza has a price, and each topping adds to the total price.  Currently, the pricing logic is implemented using a series of nested if-else statements, which has become difficult to maintain and extend as new toppings and offers are introduced. You need to refactor the pricing logic to be more flexible and extensible.",
        "code": "import java.util.List;\n\npublic class Pizza {\n\n    private String name;\n    private double basePrice;\n    private List<String> toppings;\n\n    public Pizza(String name, double basePrice, List<String> toppings) {\n        this.name = name;\n        this.basePrice = basePrice;\n        this.toppings = toppings;\n    }\n\n\n    public double calculatePrice() {\n        double price = basePrice;\n        if (toppings.contains(\"Pepperoni\")) {\n            price += 2.0;\n        }\n        if (toppings.contains(\"Mushrooms\")) {\n            price += 1.5;\n        }\n        if (toppings.contains(\"Onions\")) {\n            price += 1.0;\n        }\n        if(toppings.contains(\"Pepperoni\") && toppings.contains(\"Mushrooms\")){\n            price -= 0.5; // Special combo discount!\n        }\n         // More if-else blocks for other toppings and combinations\u2026\n\n        return price;\n    }\n\n\n    public static void main(String[] args) {\n        List<String> toppings = List.of(\"Pepperoni\", \"Mushrooms\");\n        Pizza pizza = new Pizza(\"Pepperoni Feast\", 10.0, toppings);\n        System.out.println(\"Price: $\" + pizza.calculatePrice()); //Expected 13\n\n        List<String> toppings2 = List.of(\"Pepperoni\", \"Mushrooms\", \"Onions\");\n        Pizza pizza2 = new Pizza(\"Veggie Supreme\", 12.0, toppings2);\n        System.out.println(\"Price: $\" + pizza2.calculatePrice());\n\n\n    }\n}\n\n\n\ninterface ToppingDecorator{\n    double getCost();\n}"
    },
    {
        "question_id": 29,
        "design_pattern": "complex-decorator",
        "context": "You are building a pizza ordering system for a new artisanal pizza shop.  Customers can customize their pizzas with various toppings, each having a different price.  The shop offers some standard combinations (like \"Margherita\" or \"Pepperoni\"), but also allows full customization.  The pricing needs to be flexible and easily extendable as new toppings and combinations are introduced. Currently, the pricing calculation is a messy nested `if-else` block and it's becoming difficult to manage.",
        "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Pizza {\n\n    private String base;\n    private List<String> toppings;\n    private double price;\n\n    public Pizza(String base) {\n        this.base = base;\n        this.toppings = new ArrayList<>();\n        this.price = 0;\n        if (base.equals(\"Thin Crust\")) {\n            this.price += 8.0;\n        } else if (base.equals(\"Thick Crust\")) {\n            this.price += 10.0;\n        }\n    }\n\n    public void addTopping(String topping) {\n        this.toppings.add(topping);\n        if (topping.equals(\"Pepperoni\")) {\n            this.price += 2.0;\n        } else if (topping.equals(\"Mushrooms\")) {\n            this.price += 1.5;\n        } else if (topping.equals(\"Onions\")) {\n            this.price += 1.0;\n        } else if (topping.equals(\"Extra Cheese\")) {\n            this.price += 1.5;\n        }\n         // Many more toppings with complex pricing based on base\n        if (base.equals(\"Thick Crust\") && topping.equals(\"Extra Cheese\")){\n            this.price += 0.5; // Extra charge for extra cheese on thick crust\n        }\n    }\n\n\n    public double getPrice() {\n        return price;\n    }\n\n\n    public static void main(String[] args) {\n        Pizza pizza = new Pizza(\"Thin Crust\");\n        pizza.addTopping(\"Pepperoni\");\n        pizza.addTopping(\"Mushrooms\");\n        System.out.println(\"Pizza price: \" + pizza.getPrice());\n\n\n        Pizza pizza2 = new Pizza(\"Thick Crust\");\n        pizza2.addTopping(\"Extra Cheese\");\n        System.out.println(\"Pizza price: \" + pizza2.getPrice());\n\n\n    }\n}"
    },
    {
        "question_id": 30,
        "design_pattern": "complex-decorator",
        "context": "You are developing a pizza ordering system for a popular pizza chain. Customers can customize their pizzas with various toppings. Each topping has a cost associated with it, and some toppings may have preparation requirements that depend on other toppings. For example, extra cheese must be added before adding pepperoni, or the pepperoni will slide off during baking.  The current system struggles to manage the pricing and ordering of complex topping combinations efficiently and correctly applies preparation steps.",
        "code": "import java.util.ArrayList;\nimport java.util.List;\n\ninterface Pizza {\n    double getCost();\n    String getDescription();\n    void prepare();\n}\n\nclass BasicPizza implements Pizza {\n    public double getCost() {\n        return 8.0;\n    }\n\n    public String getDescription() {\n        return \"Basic Pizza\";\n    }\n\n    public void prepare(){\n        System.out.println(\"Preparing base pizza...\");\n    }\n}\n\nclass ToppingDecorator implements Pizza {\n    protected Pizza pizza;\n\n    public ToppingDecorator(Pizza pizza) {\n        this.pizza = pizza;\n    }\n\n    public double getCost() {\n        return pizza.getCost();\n    }\n\n    public String getDescription() {\n        return pizza.getDescription();\n    }\n\n    public void prepare() {\n        pizza.prepare();\n    }\n}\n\n\nclass Cheese extends ToppingDecorator {\n    public Cheese(Pizza pizza) {\n        super(pizza);\n    }\n\n    public double getCost() {\n        return pizza.getCost() + 1.5;\n    }\n\n    public String getDescription() {\n        return pizza.getDescription() + \", Extra Cheese\";\n    }\n\n    public void prepare(){\n        System.out.println(\"Adding cheese...\");\n        pizza.prepare();\n    }\n}\n\nclass Pepperoni extends ToppingDecorator {\n    public Pepperoni(Pizza pizza) {\n        super(pizza);\n    }\n\n    public double getCost() {\n        return pizza.getCost() + 2.0;\n    }\n\n    public String getDescription() {\n        return pizza.getDescription() + \", Pepperoni\";\n    }\n\n    public void prepare(){\n        System.out.println(\"Adding pepperoni...\");\n        pizza.prepare(); // Pepperoni should ideally be added AFTER cheese if cheese is present\n    }\n}\n\n\npublic class Main {\n    public static void main(String[] args) {\n        Pizza pizza = new BasicPizza();\n        pizza = new Cheese(pizza);\n        pizza = new Pepperoni(pizza);\n\n        System.out.println(\"Cost: $\" + pizza.getCost());\n        System.out.println(\"Description: \" + pizza.getDescription());\n        pizza.prepare();\n\n\n    }\n}"
    },
    {
        "question_id": 31,
        "design_pattern": "microservices-patterns",
        "context": "A rapidly growing e-commerce platform, \"ShopSphere,\" initially implemented its entire system as a monolithic application. As the platform expanded, adding new features like product recommendations, inventory management, and order processing became increasingly complex and slow.  Deployments became risky, and scaling specific parts of the system independently was impossible.  They've decided to migrate towards a microservices architecture, starting with the order processing component. Currently, the order processing logic is tightly coupled within the main application.  This leads to long build times and makes it difficult to scale order processing independently during peak shopping periods.  Your task is to refactor the order processing functionality into a separate microservice using suitable microservices patterns.",
        "code": "import java.util.UUID;\n\npublic class OrderProcessor {\n\n    private InventoryManager inventoryManager;\n    private PaymentGateway paymentGateway;\n    private EmailService emailService;\n\n    public OrderProcessor() {\n        this.inventoryManager = new InventoryManager();\n        this.paymentGateway = new PaymentGateway();\n        this.emailService = new EmailService();\n    }\n\n    public void processOrder(Order order) {\n        // Check inventory\n        if (!inventoryManager.checkAvailability(order.getItems())) {\n            throw new RuntimeException(\"Items not in stock\");\n        }\n\n        // Process payment\n        try {\n            paymentGateway.processPayment(order.getPaymentInfo());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Payment failed\");\n        }\n\n        // Update inventory\n        inventoryManager.updateInventory(order.getItems());\n\n        // Send confirmation email\n        emailService.sendEmail(order.getCustomerEmail(), \"Order Confirmed\", \"Your order has been placed.\");\n\n        order.setStatus(\"Processed\");\n        System.out.println(\"Order \" + order.getOrderId() + \" processed successfully.\");\n    }\n\n\n    public static void main(String[] args) {\n        Order order = new Order(UUID.randomUUID().toString(), new Items(), new PaymentInfo(), \"customer@example.com\");\n        OrderProcessor processor = new OrderProcessor();\n        processor.processOrder(order);\n    }\n\n}\n\nclass Order {\n    String orderId;\n    Items items;\n    PaymentInfo paymentInfo;\n    String customerEmail;\n    String status;\n\n    // Constructor, getters and setters\n\n    public Order(String orderId, Items items, PaymentInfo paymentInfo, String customerEmail) {\n        this.orderId = orderId;\n        this.items = items;\n        this.paymentInfo = paymentInfo;\n        this.customerEmail = customerEmail;\n    }\n\n    // ... (Getters and setters for orderId, items, paymentInfo, customerEmail, status)\n}\n\n\nclass Items {}\n\nclass PaymentInfo {}\n\nclass InventoryManager {\n    public boolean checkAvailability(Items items) { return true;}\n    public void updateInventory(Items items) {}\n}\nclass PaymentGateway {\n    public void processPayment(PaymentInfo paymentInfo) {}\n}\nclass EmailService { public void sendEmail(String email, String subject, String body) {} }"
    },
    {
        "question_id": 32,
        "design_pattern": "microservices-patterns",
        "context": "You are developing an e-commerce platform.  Currently, the entire system is a monolithic application.  Customers are experiencing slow response times, especially during peak hours, when placing orders.  Furthermore, deploying new features or bug fixes is a risky and time-consuming process, often requiring the entire system to be taken offline. You need to improve the scalability and maintainability of the order processing functionality by adopting a microservices architecture.  Specifically, you need to decouple the order creation process from the payment processing and inventory management functionalities.",
        "code": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class OrderService {\n\n    private Map<String, Double> inventory = new HashMap<>();\n\n    public OrderService() {\n        inventory.put(\"Laptop\", 1200.0);\n        inventory.put(\"Mouse\", 25.0);\n        inventory.put(\"Keyboard\", 75.0);\n    }\n\n    public String createOrder(String itemName, int quantity) {\n        if (!inventory.containsKey(itemName)) {\n            return \"Item not found\";\n        }\n\n        double price = inventory.get(itemName);\n        double totalPrice = price * quantity;\n\n        // Deduct from inventory\n        inventory.put(itemName, inventory.get(itemName) - quantity);\n\n\n        // Process payment (simulated)\n        boolean paymentSuccessful = processPayment(totalPrice);\n\n        if (paymentSuccessful) {\n            return \"Order created successfully. Total: $\" + totalPrice;\n        } else {\n            // Add back to inventory if payment fails\n            inventory.put(itemName, inventory.get(itemName) + quantity);\n            return \"Payment failed\";\n        }\n\n    }\n\n\n    private boolean processPayment(double amount) {\n        // Simulate payment processing (sometimes fails)\n        return Math.random() > 0.2; // 80% success rate\n    }\n\n    public static void main(String[] args) {\n        OrderService orderService = new OrderService();\n        System.out.println(orderService.createOrder(\"Laptop\", 1));\n    }\n}"
    },
    {
        "question_id": 33,
        "design_pattern": "microservices-patterns",
        "context": "You are developing an e-commerce platform.  Customers can browse products, add them to their cart, and proceed to checkout. Currently, the entire system is implemented as a monolithic application. This architecture is proving difficult to scale and maintain, especially during peak shopping seasons. You experience frequent outages and slow response times when the number of concurrent users increases. You decide to migrate to a microservices architecture to improve scalability and resilience. You are starting with the \"Product Catalog\" and \"Cart\" functionalities, extracting them into separate microservices.  You need to implement inter-service communication between these two microservices.  The `ProductCatalogService` should be able to handle requests for product information, and the `CartService` should be able to add products to a user's cart, retrieving product details from the `ProductCatalogService`.",
        "code": "import java.util.HashMap;\nimport java.util.Map;\n\n// Product Catalog Service\nclass ProductCatalogService {\n    private Map<String, Product> products;\n\n    public ProductCatalogService() {\n        products = new HashMap<>();\n        products.put(\"123\", new Product(\"123\", \"Laptop\", 1200.00));\n        products.put(\"456\", new Product(\"456\", \"Mouse\", 25.00));\n    }\n\n    public Product getProduct(String productId) {\n        return products.get(productId);\n    }\n}\n\n// Cart Service\nclass CartService {\n    private Map<String, Cart> carts;\n    private ProductCatalogService productCatalogService;\n\n\n    public CartService() {\n        carts = new HashMap<>();\n        productCatalogService = new ProductCatalogService(); // Direct dependency\n    }\n\n\n    public void addItemToCart(String userId, String productId) {\n        Cart cart = carts.getOrDefault(userId, new Cart(userId));\n\n        Product product = productCatalogService.getProduct(productId);\n\n        if (product != null) {\n            cart.addItem(product);\n            carts.put(userId, cart);\n        } else {\n            System.out.println(\"Product not found\");\n        }\n\n    }\n\n\n\n}\n\n\nclass Product {\n    String id;\n    String name;\n    double price;\n\n    public Product(String id, String name, double price) {\n        this.id = id;\n        this.name = name;\n        this.price = price;\n    }\n\n    // ... getters and setters ...\n}\n\nclass Cart {\n    String userId;\n    // ... other cart details ...\n\n    public Cart(String userId) {\n        this.userId = userId;\n    }\n\n    public void addItem(Product product) {\n       // ... logic to add item to cart ...\n        System.out.println(\"Added \" + product.name + \" to cart.\");\n\n    }\n\n    // ... other methods ...\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        CartService cartService = new CartService();\n        cartService.addItemToCart(\"user123\", \"123\");\n\n\n    }\n}"
    },
    {
        "question_id": 34,
        "design_pattern": "pattern-combinations",
        "context": "You are developing a pizza ordering system for a new restaurant chain.  Customers can customize their pizzas with a wide variety of toppings. The system needs to handle creating pizzas with any combination of toppings efficiently, without creating a separate class for each possible combination.  The toppings include Pepperoni, Mushrooms, Onions, Olives, and Extra Cheese. Currently, the system uses a large, messy `if-else` block to determine the price based on the selected toppings.  This approach is difficult to maintain and extend as new toppings are added.  Refactor the system to use a combination of design patterns to handle this complexity.",
        "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Pizza {\n\n    private double basePrice = 10.0;\n    private List<String> toppings = new ArrayList<>();\n\n    public void addTopping(String topping) {\n        toppings.add(topping);\n    }\n\n    public double calculatePrice() {\n        double price = basePrice;\n\n        if (toppings.contains(\"Pepperoni\")) {\n            price += 2.0;\n        }\n        if (toppings.contains(\"Mushrooms\")) {\n            price += 1.5;\n        }\n        if (toppings.contains(\"Onions\")) {\n            price += 1.0;\n        }\n        if (toppings.contains(\"Olives\")) {\n            price += 0.75;\n        }\n        if (toppings.contains(\"Extra Cheese\")) {\n            price += 1.25;\n        }\n\n        // Special offer: Pepperoni and Mushrooms together cost 3.0 instead of 3.5\n        if (toppings.contains(\"Pepperoni\") && toppings.contains(\"Mushrooms\")) {\n            price -= 0.5;\n        }\n\n        // More special offers could be added here... leading to a long and complex if/else structure.\n\n\n        return price;\n    }\n\n    public static void main(String[] args) {\n        Pizza pizza = new Pizza();\n        pizza.addTopping(\"Pepperoni\");\n        pizza.addTopping(\"Mushrooms\");\n        System.out.println(\"Pizza price: $\" + pizza.calculatePrice());\n\n        Pizza pizza2 = new Pizza();\n        pizza2.addTopping(\"Onions\");\n        pizza2.addTopping(\"Olives\");\n        pizza2.addTopping(\"Extra Cheese\");\n        System.out.println(\"Pizza price: $\" + pizza2.calculatePrice());\n\n       //Demonstrating adding more toppings increases complexity with the if/else block\n        Pizza pizza3 = new Pizza();\n        pizza3.addTopping(\"Onions\");\n        pizza3.addTopping(\"Olives\");\n        pizza3.addTopping(\"Extra Cheese\");\n        pizza3.addTopping(\"Pepperoni\");\n        System.out.println(\"Pizza price: $\" + pizza3.calculatePrice());\n    }\n}"
    },
    {
        "question_id": 35,
        "design_pattern": "pattern-combinations",
        "context": "You are developing a pizza ordering system for a new online restaurant. Customers can customize their pizzas with various toppings and crust types.  The restaurant offers different deals and discounts, such as \"Buy one get one free\" on Tuesdays, or a 20% discount on orders over $30.  Currently, the system is implemented with a large, messy `if-else` block that handles all combinations of pizza options, deals, and discounts.  This makes the code hard to maintain and extend.  Refactor the code using a combination of design patterns to improve its flexibility and maintainability.  Consider using the Decorator pattern for toppings and crusts, the Strategy pattern for discounts, and the Composite pattern for combining multiple deals.",
        "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Pizza {\n\n    private String crust;\n    private List<String> toppings;\n    private double price;\n\n    public Pizza(String crust, double price) {\n        this.crust = crust;\n        this.toppings = new ArrayList<>();\n        this.price = price;\n    }\n\n    public void addTopping(String topping) {\n        this.toppings.add(topping);\n        this.price += 1.5; // All toppings cost $1.5\n    }\n\n    public double calculatePrice() {\n        double finalPrice = this.price;\n\n        // Tuesday BOGO deal\n        if (java.time.LocalDate.now().getDayOfWeek().getValue() == 2) {\n            finalPrice *= 0.5;\n        }\n\n        // Over $30 discount\n        if (finalPrice > 30) {\n            finalPrice *= 0.8;\n        }\n\n\n        return finalPrice;\n    }\n\n\n    public static void main(String[] args) {\n        Pizza pizza = new Pizza(\"thin\", 10.0);\n        pizza.addTopping(\"pepperoni\");\n        pizza.addTopping(\"mushrooms\");\n\n        System.out.println(\"Total price: $\" + pizza.calculatePrice());\n\n\n    }\n}\n\n\ninterface Discount {\n    double applyDiscount(double price);\n}\n\nclass TuesdayDiscount implements Discount {\n\n    @Override\n    public double applyDiscount(double price) {\n        return price * 0.5;\n    }\n}\n\nclass Over30Discount implements Discount{\n\n    @Override\n    public double applyDiscount(double price) {\n        if(price > 30) {\n            return price * 0.8;\n        }\n\n        return price;\n    }\n}"
    },
    {
        "question_id": 36,
        "design_pattern": "pattern-combinations",
        "context": "You are developing a pizza ordering system. Customers can customize their pizzas with various toppings and crust types.  Currently, the system has separate classes for each crust type (ThinCrustPizza, ThickCrustPizza) and each topping (Pepperoni, Mushrooms, Olives).  Adding new crusts and toppings requires creating new classes, leading to a combinatorial explosion of classes.  This makes the system difficult to maintain and extend. Refactor the system using appropriate design patterns to handle the growing number of combinations efficiently.",
        "code": "public abstract class Pizza {\n    String crust;\n    String description;\n    double cost;\n\n    public String getDescription() {\n        return description;\n    }\n\n    public double getCost() {\n        return cost;\n    }\n\n    public abstract void prepare();\n\n}\n\n\npublic class ThinCrustPizza extends Pizza {\n\n    public ThinCrustPizza() {\n        description = \"Thin crust pizza\";\n        crust = \"Thin\";\n        cost = 8.0;\n    }\n\n    public void prepare() {\n        System.out.println(\"Preparing thin crust pizza...\");\n    }\n}\n\n\npublic class ThickCrustPizza extends Pizza {\n\n    public ThickCrustPizza() {\n        description = \"Thick crust pizza\";\n        crust = \"Thick\";\n        cost = 10.0;\n    }\n\n    public void prepare() {\n        System.out.println(\"Preparing thick crust pizza...\");\n    }\n}\n\n\npublic class Pepperoni {\n\n    public String getDescription() {\n        return \"Pepperoni\";\n    }\n    public double getCost(){\n        return 2.0;\n    }\n}\n\npublic class Mushrooms {\n\n    public String getDescription() {\n        return \"Mushrooms\";\n    }\n    public double getCost(){\n        return 1.5;\n    }\n\n}\n\npublic class Olives {\n\n    public String getDescription() {\n        return \"Olives\";\n    }\n    public double getCost(){\n        return 1.0;\n    }\n\n}\n\npublic class PizzaMaker {\n    public static void main(String[] args) {\n        ThinCrustPizza thinCrustPizza = new ThinCrustPizza();\n        Pepperoni pepperoni = new Pepperoni();\n\n        System.out.println(thinCrustPizza.getDescription() + \" with \" + pepperoni.getDescription());\n        System.out.println(\"Total cost: $\" + (thinCrustPizza.getCost() + pepperoni.getCost()));\n\n\n        ThickCrustPizza thickCrustPizza = new ThickCrustPizza();\n        Mushrooms mushrooms = new Mushrooms();\n        Olives olives = new Olives();\n\n        System.out.println(thickCrustPizza.getDescription() + \" with \" + mushrooms.getDescription() + \" and \" + olives.getDescription());\n        System.out.println(\"Total cost: $\" + (thickCrustPizza.getCost() + mushrooms.getCost() + olives.getCost()));\n\n    }\n}"
    }
]